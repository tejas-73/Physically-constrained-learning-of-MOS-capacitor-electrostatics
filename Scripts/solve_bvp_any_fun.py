'''
The Function Considered here is:
y = 0.5*x**2 + x + 1,  -10<= x <= 10

Therefore, the problem becomes:
y`` = 1

so, y`(-10) = -9 and y(10) = 61 Becomes the boundary conditions, which are consideredd here.
since solve_bvp is used only for a single order differential equation, we will have to reframe the problem

Let`s call:
c1 = y
c2 = c1` = y`
c2` = 1 (From the Differential equation)

Therefore, in the function, "bc" conditions are elaborated as
#Note that here (a, b) = (-10, 10)
c1a, c2a, that will correspond to y@a and y`@a
c1b, c2b, that will correspond to y@b and y`@b
and note that we just have boundary value conditions on
y`(a) and y(b)


Similarly, we can extend to different orders and different complexities of differential Equation.
Have implemented for poisson equation for same case

Reference:
https://www.youtube.com/watch?v=vWcRuay1tt4&t=1137s
'''

'''

Generates solution for Poisson equation using spline based methods.

'''


import os

from scipy.integrate import solve_bvp
import numpy as np
import matplotlib.pyplot as plt
import math
import argparse
from tqdm import tqdm

parser = argparse.ArgumentParser(description='Model Variables')
parser.add_argument('Vgs', type=float, help='Value of Vgs')
parser.add_argument('t_ox', type=float, help='Enter the tox value in nm')
parser.add_argument('N_A', type=float, help='Enter the N_A value as a coefficient to 1e24')
parser.add_argument('train_samples', type=int, help='Number of Training Samples')
parser.add_argument('batch_size', type=int, help='The total number of batches to be formed from the training samples')
parser.add_argument('lr', type=float, help='learning rate of the model')
parser.add_argument('do_training', type=int, help='Set 1 to perform Training')
parser.add_argument('train_w_gt', type=int, help='Set 1 to train only on Data generated by FEM')
parser.add_argument('include_gt_loss', type=int, help='Include FEM data for training. Set 1 to include else 0')
parser.add_argument('save_model_tag', type=str, help='tag with which to save the model or saved model tag for inference')
parser.add_argument('training_data_reference', type=str, help='tag for dataset to choose for training')
parser.add_argument('test_dataset_reference', type=str, help='tag for dataset to choose for training')
parser.add_argument('update_text_file', type=int, help='Update the text file', default=0)
parse = parser.parse_args()

train_samples = parse.train_samples

N_A = parse.N_A*1e24
t_ox = parse.t_ox * 1e-9 #1e-9
t_si = 200e-9 #5e-8
epsilon_0 = 8.85418781e-12
epsilon_si = epsilon_0*11.9
epsilon_sio2 = epsilon_0*3.9
delta_psi_MS = 0.21
psi_t = 26e-3 #26e-3
n_i = 1e16
psi_F = psi_t*math.log(N_A/n_i)
q = 1.6e-19
Cox = epsilon_sio2 / t_ox
C_ = (n_i/N_A)**2

print(f"This is t_si = {t_si :e}")

def get_vgs():
    Vgs = np.load(f'./{parse.save_model_tag}_vgs.npy')
    return Vgs

def get_t_ox():
    t_ox = np.load(f'./{parse.save_model_tag}_t_ox.npy')
    return t_ox

def get_N_A():
    N_A = np.load(f'./{parse.save_model_tag}_N_A.npy')
    return N_A


def function(x, C):
    c1, c2 = C #c1 corresponds to actual y, and c2 corresponds to c1`=y`
    dc1dx = c2
    dc2dx = np.ones((C.shape[1], ))
    return [dc1dx, dc2dx]


def bc(Ca, Cb):
    c1a, c2a = Ca #Solutions of C at "a" boundary. Note how c1 and c2 are defined. Here we will be having values for y, y` at boundary a
    c1b, c2b = Cb #Solutions of C at "b" boundary. Here we will be having values for y, y` at boundary b
    return [c2a + 9,  #Equivalent to c1`(-10) = -9
            c1b - 61] #Equivalent to say that c1(10) = 61


def solve_bvp_given_function():
    time = np.linspace(-10, 10, 1000) #note that the boundaries are something which correspond to boundary condition. i.e. here boundary conditions are to be defined at -10 & 10,
                                                        #These are the nodes of the Mesh
    y = np.zeros((2, time.__len__())) #Initial assumption of y. y has rows as c1 and c2, and these are the values for different values of x
    for i in time:
        solution = solve_bvp(function, bc, time, y, tol=1e-3, max_nodes=20000)
    y_true = 0.5*time**2 + time + 1 #Actual Solution to the problem
    plt.plot(time, solution.sol(time)[0], label='First') #The argument [0] is significant here because solution.sol will give solution to both c1 and c2 and we are interested in c1
    plt.plot(time, y_true, label='Second')
    plt.legend(['First', 'Second'])
    plt.xlabel("Vertical Distance, y (nm)", fontsize=5)
    plt.ylabel("Potential, $\psi(y)$    (V)", fontsize=5)
    plt.xticks(fontsize=15)
    plt.yticks(fontsize=15)
    plt.show()


def function_poisson(x, C):
    c1, c2 = C #c1 corresponds to actual y, and c2 corresponds to c1`=y`
    dc1dy = c2
    dc2dy = -((q*get_N_A())/epsilon_si)*(np.exp(-c1/(psi_t)) - 1 - (np.exp((-2*psi_t*math.log(get_N_A()/n_i))/psi_t))*(np.exp(c1/(psi_t)) - 1))
    return [dc1dy, dc2dy]


def bc_poisson(psi_a, psi_b):
    c1a, c2a = psi_a
    c1b, c2b = psi_b
    return [c2a + ((epsilon_sio2/get_t_ox())/epsilon_si)*(get_vgs() - c1a),
                                c1b]


def main(need_psi0_list=False, save_ground_truth=False, need_psi0=False, VGS=None, Tox=None, NA=None, psi0_samples=500, y_new=None, if_print=True):
    if not (VGS is None):
        np.save(f'./{parse.save_model_tag}_vgs.npy', VGS)
    if Tox:
        np.save(f'./{parse.save_model_tag}_t_ox.npy', Tox)
    else:
        np.save(f'./{parse.save_model_tag}_t_ox.npy', t_ox)
    if NA:
        np.save(f'./{parse.save_model_tag}_N_A.npy', NA)
    else:
        np.save(f'./{parse.save_model_tag}_N_A.npy', N_A)
    if not (y_new is None):
        y = y_new
    else:
        y = np.linspace(0, t_si, train_samples)
    psi = np.zeros((2, y.shape[0]))
    Vgs = get_vgs()
    sol = solve_bvp(function_poisson, bc_poisson, y, psi, tol=1e-5, max_nodes=20000) #1e-5, 100000
    if if_print:
        print(Vgs)
        print(f"{sol.sol(y)[0][0], sol.sol(y)[1][0]}")
        print()
        print(f"{sol.sol(y)[0][-1], sol.sol(y)[1][-1]}")
    if save_ground_truth:
        plt.plot(y, (sol.sol(y)[0]))
        plt.savefig('Ground_Truth.png')
        plt.close()
    if need_psi0:
        return sol.sol(y)[0][0]
    required_array = np.array(sol.sol(y))
    psi0_list = []
    if need_psi0_list:
        Vg = np.linspace(-Vgs, Vgs, psi0_samples, dtype=np.float64)
        y__ = np.linspace(0, t_si, 100)
        psi = np.zeros((2, y__.shape[0]))
        for i in tqdm(Vg):
            np.save(f'./{parse.save_model_tag}_vgs.npy', np.round_(i, 5))
            sol = solve_bvp(function_poisson, bc_poisson, y__, psi, tol=1e-5, max_nodes=20000)
            psi0_list.append(sol.sol(np.where(y==0))[0].ravel())
        return required_array, psi0_list
    return required_array, sol.sol(y)[0][0]

if __name__ == '__main__':
    main(True, True)